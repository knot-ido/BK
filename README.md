# 快速排序
- 快速排序就是挖坑填坑的过程
## 代码及讲解
- 1、先写出main函数以及需要排序的数组
```
#include<iostream>
int main(){
    int num[10]={1,9,2,8,3,7,6,4,5,10};
    return 0;
}
```
- 2、写快排函数
    - 因为是直接修改的原数组里的数字排序，所以不需要返回值
    - 传入的参数有3个：左角标、右角标、数组
```
void Quick(int z,int y,int num[]){
    int _z=z;
    int _y=y;
    int sum=num[_z];//存放基准数，用作对比。
    while(_z<_y&&sum<=num[_y]){//右侧比基准数大的
        _y--;
    }
    if(_z<_y){
        //找到一个小于基准数的
        num[_z]=num[_y];//把右侧小于基准数的值挖出来放到左侧坑
        _z++;//左侧坑填了，从被填坑的下一个开始
    }
    while(_z<_y&&sum>=num[_z]){
        //左侧比基准数小的
        _z++;
    }
    if(_z<_y){
        num[_y]=num[_z];//左侧比基准数小的，挖出来，放到右侧
        _y--;//右侧角标前移
    }
}
```
- 到这里，第一轮排序结束
    - 完成了把一个比基准数小的放到左侧，比基准数大的放到右侧
# 进行多轮排序
- 实现把所有比基准数小的放到右侧，所有比基准数大的，放大左侧
```
while(_z<_y){
    //这里放上面的执行一遍的代码
}
```
- 执行完上述操作后就完成了一次排序
- 然后把最先挖出来的基准数放回最后的坑里
```
while(_z<_y){
    //这里放上面的执行一遍的代码
}
num[_z]=sum;//放到上一步while循环外的下一行，像这样
```
- 现在基准数左侧的都比他小
- 右侧的都比他大
# 然后对基准数的左侧和右侧分别排序
- 在函数内使用递归调用即可
``` 
Quick(z,_z-1,num);
Quick(_z+1,y,num);
```
这样就会重复递归调用函数，但还要添加一个终止判断来结束递归
```
if(_z<_y){
  //把执行排序的部分放入这里即可  
}
```
# 总结
```
if(_z<_y){
  while(_z<_y){
    //这里放上面的执行一遍的代码
}
num[_z]=sum; 
Quick(z,_z-1,num);
Quick(_z+1,y,num);
}
```
